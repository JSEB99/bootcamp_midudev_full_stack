<!DOCTYPE html>
<html>
<head>
<title>css_notes.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 style="text-align:center;color:crimson;font-size:50px;">Notas CSS</h1>
<h2 id="fuentes">Fuentes</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=TlJbu0BMLaY">Midudev Curso CSS</a></li>
<li><a href="https://lenguajecss.com/">Manz Dev</a></li>
<li><a href="https://web.dev/learn/css?hl=es">Curso CSS Google</a></li>
</ul>
<h2 id="herramientas">Herramientas</h2>
<ul>
<li><a href="https://codi.link/">Codi Link</a></li>
</ul>
<h2 id="contenido">Contenido</h2>
<ul>
<li><a href="#fuentes">Fuentes</a></li>
<li><a href="#herramientas">Herramientas</a></li>
<li><a href="#contenido">Contenido</a></li>
<li><a href="#donde-poner-los-estilos">¿Donde poner los estilos?</a></li>
<li><a href="#partes-de-css">Partes de CSS</a></li>
<li><a href="#colores">Colores</a>
<ul>
<li><a href="#current-color">Current color</a></li>
</ul>
</li>
<li><a href="#selectores">Selectores</a></li>
<li><a href="#herencia">Herencia</a>
<ul>
<li><a href="#c%C3%B3mo-se-si-hereda-o-no">¿Cómo se si hereda o no?</a></li>
</ul>
</li>
<li><a href="#pseudo-clases">Pseudo-clases</a></li>
<li><a href="#borde-y-contorno">Borde y Contorno</a></li>
<li><a href="#first-child-last-child">first-child, last-child</a></li>
<li><a href="#multilples-selectores">Multilples selectores</a></li>
<li><a href="#operador---afectar-por-nivel-">Operador - Afectar por nivel <code>&gt;</code></a></li>
<li><a href="#operador---hermano-siguiente-">Operador - Hermano siguiente <code>~</code></a></li>
<li><a href="#operador---plus-inmediatamente-despues-">Operador - plus <em>(Inmediatamente despues)</em> <code>+</code></a></li>
<li><a href="#cascada">Cascada</a></li>
<li><a href="#fallbacks">Fallbacks</a></li>
<li><a href="#especificidad">Especificidad</a></li>
<li><a href="#unidades">Unidades</a>
<ul>
<li><a href="#absoultas">Absoultas</a></li>
<li><a href="#relativas">Relativas</a></li>
</ul>
</li>
<li><a href="#reset-css-y-normalize">Reset CSS y Normalize</a></li>
<li><a href="#modelo-de-la-caja">Modelo de la caja</a>
<ul>
<li><a href="#padding">Padding</a></li>
<li><a href="#border">Border</a></li>
<li><a href="#margin">Margin</a></li>
<li><a href="#box-sizing">Box-Sizing</a></li>
</ul>
</li>
<li><a href="#overflow">Overflow</a>
<ul>
<li><a href="#soluciones">Soluciones?</a></li>
</ul>
</li>
<li><a href="#position">Position</a>
<ul>
<li><a href="#absolute">Absolute</a></li>
<li><a href="#relative">Relative</a></li>
<li><a href="#fixed">Fixed</a></li>
<li><a href="#sticky">Sticky</a></li>
</ul>
</li>
<li><a href="#z-index">z-index</a></li>
<li><a href="#flexbox">Flexbox</a>
<ul>
<li><a href="#c%C3%B3mo-le-cambio-de-filas-a-columnas-o-vice-versa">¿Cómo le cambio de filas a columnas o vice-versa?</a></li>
<li><a href="#flex-wrap">Flex-wrap</a></li>
<li><a href="#c%C3%B3mo-controlo-el-espacio-de-los-elementos-flexibles">¿Cómo controlo el espacio de los elementos flexibles?</a></li>
<li><a href="#le-puedo-cambiar-el-orden-a-los-elementos">¿Le puedo cambiar el orden a los elementos?</a></li>
<li><a href="#justify-content">Justify-content</a></li>
<li><a href="#gap">Gap</a></li>
<li><a href="#align-items">Align-items</a></li>
<li><a href="#align-content">Align-content</a></li>
<li><a href="#align-self">Align-self</a></li>
</ul>
</li>
<li><a href="#grid">Grid</a>
<ul>
<li><a href="#unidad-especial">Unidad especial</a></li>
<li><a href="#filas-autom%C3%A1ticas">Filas automáticas</a></li>
<li><a href="#grid-auto-flow">Grid-auto-flow</a></li>
</ul>
</li>
</ul>
<h2 id="%C2%BFdonde-poner-los-estilos">¿Donde poner los estilos?</h2>
<p>Se recomienda ubicar dentro del head con link directo hacia los estilos. <strong>La sintaxis permite ubicarlos donde uno quiere ya sean</strong>:</p>
<ul>
<li>En linea</li>
<li>En el body</li>
<li>En el head sin link</li>
<li>En el head con link</li>
</ul>
<blockquote>
<p>[!NOTE]
Existen estilos por defecto que vienen integrados con el navegador</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">&lt;!-- Versión dentro de head sin link--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    <span class="hljs-selector-tag">selector</span> {
        <span class="hljs-attribute">propiedad</span>: valor; <span class="hljs-comment">/*Declaración*/</span>
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-comment">&lt;!-- Recomendación --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"ubicacion archivo css"</span>&gt;</span>
</div></code></pre>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="partes-de-css">Partes de CSS</h2>
<ul>
<li><strong>Selector:</strong> Donde seleccionamos el <strong>elemento</strong> que queremos estilar</li>
<li><strong>Propiedad:</strong> A que atributo vamos a afectar del elemento</li>
<li><strong>valor:</strong> Que valor le pondremos al atributo</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-selector-tag">selector</span> {  
    <span class="hljs-attribute">propiedad</span>: valor;
}
</div></code></pre>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="colores">Colores</h2>
<pre class="hljs"><code><div><span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: red; <span class="hljs-comment">/*Valores predeterminados para colores*/</span>
    <span class="hljs-comment">/*color: #000000 Versión hexadecimal*/</span>
    <span class="hljs-comment">/*color: #9fb Hexadecimal corto = #99ffbb*/</span>    
    <span class="hljs-comment">/*color: rgb(255,0,0 / 0.5) Versión rgb/a (para transparencia)*/</span>
    <span class="hljs-comment">/*color: hsl(360,0.75,0.5 / 0.5) Versión hsl/a (para transparencia)
    /*color: oklch(348, 83%, 1 / 0.5) nuevo: lightness, chroma, alpha, hue*/</span>
    <span class="hljs-comment">/*color: transparent*/</span>
}
<span class="hljs-selector-tag">body</span> { <span class="hljs-comment">/*Afecta a todo el body*/</span>
    <span class="hljs-attribute">background</span>: green;
}
</div></code></pre>
<h3 id="current-color">Current color</h3>
<p>El color se basa por defecto en el texto del <strong>elemento padre</strong></p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">border-width</span>: <span class="hljs-number">3px</span>;
    <span class="hljs-attribute">border-style</span>: solid;
    <span class="hljs-comment">/*border-color: currentColor (por defecto)*/</span>
}
</div></code></pre>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="selectores">Selectores</h2>
<p>Tipos:</p>
<ul>
<li>Por etiqueta</li>
<li><strong>Por clase:</strong> Se puede repetir</li>
<li><strong>Por identificador:</strong> Es único</li>
</ul>
<p>Ejemplo:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hola<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'subtitulo'</span>&gt;</span>Hola<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">'subtitulo'</span>&gt;</span>Hola2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'seccion-title'</span>&gt;</span>Hola3<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-selector-class">.subtitulo</span> {
    <span class="hljs-attribute">color</span>: green;
}
<span class="hljs-selector-id">#seccion-title</span> {
    <span class="hljs-attribute">color</span>: blue;
}
</div></code></pre>
<blockquote>
<p>[!TIP]
Evitar usar muchos selectores con identificadores y elementos, el <strong>objetivo</strong> es reutilizar código</p>
</blockquote>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="herencia">Herencia</h2>
<p>Algunas propiedades se heredan del <strong>elemento HTML</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hola mundo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">article</span> {
    <span class="hljs-attribute">color</span>: red
}
</div></code></pre>
<p>Entonces el h1 tiene color de texto rojo, heredando el estilo de su padre <strong>article</strong>.</p>
<blockquote>
<p>[!TIP]
La propiedad <code>font-family</code> aprovecha bastante esta propiedad para cargarla a todo el documento</p>
</blockquote>
<p>Sin embargo, podremos forzar la herencia</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
    Este es el container
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"child"</span>&gt;</span>
        hola bros
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#09f</span>;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#09f</span>
}
<span class="hljs-selector-class">.child</span> {
    <span class="hljs-comment">/*border: initial (default)*/</span>
    <span class="hljs-comment">/*border: unset (no heredables)*/</span>
    <span class="hljs-comment">/*border: revert (inherit default)*/</span>
    <span class="hljs-attribute">border</span>: inherit; <span class="hljs-comment">/*Forzas herencia*/</span>
}
</div></code></pre>
<blockquote>
<p>Es decir, ambos tendrían dos bordes con <code>inherit</code>.</p>
</blockquote>
<h3 id="%C2%BFc%C3%B3mo-se-si-hereda-o-no">¿Cómo se si hereda o no?</h3>
<p>En <a href="https://developer.mozilla.org/es/docs/Web/HTML">MDN</a> vas a la <strong>formal definition</strong> del elemento y ahí te índica si hereda o no.</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="pseudo-clases">Pseudo-clases</h2>
<p>Los elementos HTML tienen un <strong>estado</strong> base en el que se encuentran. Con las <code>pseudo-clases</code> podemos atribuirle a los elementos ciertos estados como:</p>
<ul>
<li>hover: cuando pasemos el mouse por encima</li>
<li>active: cuando damos clic <em>(en ese instante)</em></li>
<li>focus: en campos de entrada cuando le ponemos el focó <em>(estamos dentro)</em></li>
<li>etc</li>
<li><a href="https://developer.mozilla.org/es/docs/Web/CSS/Pseudo-classes">Doc pseudoclases</a></li>
</ul>
<p>En las herramientas de desarrollo podemos simular, en las opciones que muestran como por ejemplo <code>:hov</code>.</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="borde-y-contorno">Borde y Contorno</h2>
<p>La diferencia es que el borde es algo que <strong>afecta al contenido</strong> y el contorno es algo que se esta dibujando <strong>encima del contenido</strong></p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">link</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid red;
    <span class="hljs-attribute">outline</span>: <span class="hljs-number">100px</span> solid red;
}
</div></code></pre>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="first-child-last-child">first-child, last-child</h2>
<p>Es una <a href="#pseudo-clases">pseudo-clase</a> que donde tengamos varios elementos como por ejemplo listas podamos afectarlos por su orden</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item"</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item"</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item"</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>En CSS podriamos hacer esto:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.list-item</span><span class="hljs-selector-pseudo">:first-child</span>{ <span class="hljs-comment">/*Afectamos el primero*/</span>
    <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-selector-class">.list-item</span><span class="hljs-selector-pseudo">:last-child</span>{ <span class="hljs-comment">/*Afectamos el último*/</span>
    <span class="hljs-attribute">color</span>: orange;
}
</div></code></pre>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="multilples-selectores">Multilples selectores</h2>
<p>Cuando queramos afectar varios elementos con el mismo estilo, podemos usar varios elementos separados por comas como un selector combinado, de esta manera, todos ellos tendran el estilo</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">p</span>, <span class="hljs-selector-tag">a</span>{
    <span class="hljs-attribute">color</span>: purple;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;
}
</div></code></pre>
<p>De esta manera <code>h1, p y a</code> tendran <code>30px</code> de fuente con color <code>purple</code>.</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<blockquote>
<h2 id="selectores-combinados">Selectores combinados</h2>
</blockquote>
<p>Cuando queramos dar mas especificidad al selector, donde queramos afectar a cierto elemento dentro de cierto elemento podemos hacerlo mediante <code>&gt;</code> que significa <strong>conteniendo a</strong>.</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.description</span> <span class="hljs-selector-class">.bold</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#09f</span>
}
</div></code></pre>
<p>De esta manera le decimos que las clases <code>bold</code> que esten <strong>dentro</strong> de la clase <code>description</code> tengan ese determinado estilo.</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="operador---afectar-por-nivel">Operador - Afectar por nivel <code>&gt;</code></h2>
<p><strong>Pero,y si quiero que se afecte por niveles?</strong></p>
<p>Digamos tenemos una lista dentro de otra:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span> <span class="hljs-comment">&lt;!--Primer nivel--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span> <span class="hljs-comment">&lt;!--Segundo nivel--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Sub Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Sub Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>Y queramos afectar al segundo nivel, podriamos hacerlo con el operador <code>&gt;</code> para indicar cual es el nivel</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> { <span class="hljs-comment">/*Afecta a ambas listas, la 2da recibe el doble de efecto*/</span>
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">70%</span>; 
}

<span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &gt; <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> { 
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">70%</span>
}
</div></code></pre>
<p><strong>¿Cuál es la diferencia?</strong></p>
<ol>
<li><code>ul li</code>: selecciona cualquier <strong>li</strong> que este dentro de un <strong>ul</strong></li>
<li><code>li &gt; ul</code>: selecciona cualquier <strong>ul</strong> que sea <strong>hijo directo</strong> de <strong>li</strong></li>
<li><code>ul li</code>: selecciona cualquier <strong>li</strong> contenido en <strong>ul</strong></li>
</ol>
<p>Es decir, al final el efecto de opacidad solo afectará al 2do nivel</p>
<p><strong>Ejemplo 2:</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Este es el contenido del artículo<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Escrito por midudev<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span> {
    <span class="hljs-attribute">color</span>: red;
}
</div></code></pre>
<p>En este caso, solo los <strong>p</strong> que sean hijos directos de <strong>article</strong> serán afectados por el estilo</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="operador---hermano-siguiente">Operador - Hermano siguiente <code>~</code></h2>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>
        This is not red because it appears before any paragraph
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>
        This is red because it appears after any paragraph
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>
        This is red because it appears after any paragraph
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    
<span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">p</span> ~ <span class="hljs-selector-tag">span</span> {
  <span class="hljs-attribute">color</span>: red;
}
</div></code></pre>
<p>Entonces cada <code>span</code> que aparezca despues de cada <code>p</code> tendrá los estilos, <strong>NO antes de la p</strong>.</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="operador---plus-inmediatamente-despues">Operador - plus <em>(Inmediatamente despues)</em> <code>+</code></h2>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hola<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-comment">&lt;!-- Si pongo esto ya no se colorea el span &lt;h1&gt;h&lt;/h1&gt; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>
    Hola 2
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">p</span> + <span class="hljs-selector-tag">span</span> {
    <span class="hljs-attribute">color</span>: red;
}
</div></code></pre>
<p>Donde solo los <code>span</code> que estan <strong>inmediatamente despues</strong> de cada <code>p</code> se verán afectados por el estilo</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="cascada">Cascada</h2>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    Texto random
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">p</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#09f</span>;
}
<span class="hljs-comment">/*Pero*/</span>
<span class="hljs-selector-tag">p</span> {
    <span class="hljs-attribute">color</span>: red;
}
</div></code></pre>
<p>Lo que pasa al final es que el color se pondrá <strong>rojo</strong>, porque la cascada de <strong>CSS</strong> aplicará el último efecto que se puso, se <strong>sobreescribe</strong>.</p>
<p><strong>¿Cómo lo decide?</strong></p>
<p>Por posición, en el orden de aparición</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="fallbacks">Fallbacks</h2>
<p>A veces quieres usar algo moderno en <strong>CSS</strong>, pero no eta soportado en todos los navegadores, entonces para esos casos que podemos hacer:</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">p</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#09f</span>;
    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">oklch</span>(<span class="hljs-number">70%</span> <span class="hljs-number">0</span>. <span class="hljs-number">148</span> <span class="hljs-number">238.24</span>);
}
</div></code></pre>
<p>Entonces con este truco, si no funciona el <code>oklch</code> le pone el <code>#09f</code>.</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="especificidad">Especificidad</h2>
<p>Algoritmo que determina que selector <strong>CSS</strong> tiene la <strong>coincidencia</strong> mas fuerte</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text&gt;"</span>&gt;</span>Texto random<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-class">.text</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-number">#09f</span>;
}

<span class="hljs-selector-tag">p</span> {
    <span class="hljs-attribute">color</span>: red;
}
</div></code></pre>
<p>Le pone el color azul, debido a que el selector de clase es de mayor importancia.</p>
<p><strong>¿Cuál es el orden de especificidad o el Algoritmo?</strong></p>
<p>Tenemos una <a href="https://specificity.keegan.st/">Calculadora de especificidad</a></p>
<p>Donde los niveles serían asi:</p>
<ol>
<li>Si tienen <code>ID</code></li>
<li>Si tienen <code>Clases, atributos o pseudo clases</code></li>
<li>Los <code>elementos y pseudo elementos</code></li>
</ol>
<p>Estos niveles diran cuantos de dichos elementos hay y del primero al tercero van disminuyendo su importancia. Todo el selector suma todos los pesos de cada nivel y al final determina cual es puntaje total de importancia sobre otro selector.</p>
<blockquote>
<p>ej: si ambos tienen id, pero el otro tiene tambien el elemento, pues el que tiene <code>id+elemento</code> será el de mayor importancia.</p>
</blockquote>
<blockquote>
<p>[!NOTE]
Hoy en día existen <strong>metodologías</strong> de como nombrar las <code>clases</code> e <code>IDs</code> para evitar problemas de especificidad, tambien <strong>frameworks</strong> como <a href="https://tailwindcss.com/">tailwindcss</a> que se encarga de ese tema en automático.</p>
</blockquote>
<blockquote>
<p>[!WARNING]
Los estilos no solo dependen del selector, tambien del <strong>tipo de estilo</strong>, es decir, un estilo <strong>en linea</strong> tiene mas especificidad que uno de un <strong>archivo css</strong>. Asi tambien es mas especifico el estilo del usuario que el navegador.</p>
</blockquote>
<blockquote>
<p>[!IMPORTANT]
Puedes saltarte este tema de especificidad con la palabra clave <code>!important</code> en css despues de tu estilo <code>color: purple !important</code>. <em>Tener en cuenta que el important es otro nivel de especificidad de mayor importancia, porque si se tienen varios tambien se miraría cual de los dos important tiene mas especificidad (No se recomienda usar el important)</em></p>
</blockquote>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="unidades">Unidades</h2>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"containter"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">background</span>: red;
}
</div></code></pre>
<h3 id="absoultas">Absoultas</h3>
<p>Los <strong>pixeles</strong> no son unidades absolutas hoy en día, debido a que le densidad de pixeles por pulgada en las pantallas actuales ha cambiado <em>(dependera de la pantalla)</em></p>
<h3 id="relativas">Relativas</h3>
<ul>
<li>
<p>Tenemos <strong>porcentajes</strong>, dependeran del contenedor o elemento padre.</p>
</li>
<li>
<p>Tenemos <strong>em/rem</strong>, dependeran del tamaño que tiene establecido el padre: si el padre es 16px, entonces <code>2em</code> serían 32px</p>
</li>
<li>
<p>Tenemos <strong>vw/vh</strong>, dependeran del tamaño del <code>viewport</code>, es decir, tamaño de la pantalla.</p>
</li>
<li>
<p><a href="#contenido">Regresar</a></p>
</li>
</ul>
<h2 id="reset-css-y-normalize">Reset CSS y Normalize</h2>
<p>Para poder resetear las hojas de estilo que introducían los navegadores <strong>(A día de hoy no se recomienda, ya que puede eliminar estilos por defecto que pueden ser utiles)</strong>, por tal motivo salió el <code>normalize</code>, como alternativa que buscaba renderizar todos los elementos de una forma consistente en todos los navegadores, pero sin la necesidad de resetearlos al completo, dejando unos por defecto que tengan sentido en todos los navegadores.</p>
<blockquote>
<p>Hoy en día muchos <strong>frameworks</strong> ya lo traen incorporado como <a href="https://tailwindcss.com/">tailwindcss</a></p>
</blockquote>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="modelo-de-la-caja">Modelo de la caja</h2>
<p><img src="../images/box-model.png" alt="box-model"></p>
<p>Todos los elementos son cajas, unos funcionan en linea y otros en bloque.</p>
<ul>
<li><strong>linea</strong>: da un salto de linea, el elemento por defecto es el <code>span</code>, todos los elementos de este tipo <strong>se comportan como texto</strong>, es decir, no tienen ni ancho ni alto. (Este efecto es una propiedad de css <code>display: inline</code>)</li>
<li><strong>Bloque</strong>: ocupa todo el espacio horizontal (propiedad de css <code>display: block</code>)</li>
</ul>
<h3 id="padding">Padding</h3>
<p>Espacio alrededor del contenido, entre el contenido y el borde.</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span> <span class="hljs-number">8px</span> <span class="hljs-number">4px</span> <span class="hljs-number">8px</span>;
}
</div></code></pre>
<p>Los valores van desde arriba en el sentido de las manecillas del reloj, es decir, <code>arriba &gt; derecha &gt; abajo &gt; izquierda</code>. Si ponemos solo <strong>dos</strong>, sería <code>arriba-abajo derecha-izquierda</code>, y si ponemos <strong>una</strong>, sería <code>todos</code>.</p>
<h3 id="border">Border</h3>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid red;
}
</div></code></pre>
<p>Este tambien afecta el tamaño de la caja, al final tanto <code>padding</code> como <code>border</code> afectan el tamaño de la caja y el <code>width</code> afecta al tamaño del contenido. En conclusión, tendremos un tamaño del ancho de la caja total de <code>100px + 32px + 20px = 152px</code>.</p>
<h3 id="margin">Margin</h3>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid red;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;
}
</div></code></pre>
<p><strong>No afecta el tamaño de la caja</strong>, pero si separa la caja de los extremos.</p>
<h3 id="box-sizing">Box-Sizing</h3>
<p>Una propiedad de css que por defecto esta en <code>content-box</code>, es decir, que el tamaño de la caja será el contenido de la caja. Pero para evitar este cálculo, podemos usar el valor <code>border-box</code>, lo que hará que el <strong>alto</strong> y el <strong>ancho</strong> si determinarán el tamaño total de la caja, haciendo que el <code>padding</code> y el <code>border</code> esten incorporados en esas propiedades.</p>
<blockquote>
<p>Tiene que ser congruente con las demas medidas para que el ajuste tenga sentido.</p>
</blockquote>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<hr>
<h2 id="overflow">Overflow</h2>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>CSS IS AWESOME<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">48px</span>; <span class="hljs-comment">/*Muy grande*/</span>
}
</div></code></pre>
<p>Al tener un <strong>tamaño fijo</strong> de una caja hace que si el contenido <strong>llega a ser mas grande</strong>, este se <strong>desborda</strong> (se sale).</p>
<h3 id="soluciones">Soluciones?</h3>
<p>Bueno, primero entender que esta funcionando con una propiedad por defecto <code>overflow: visible</code>, para solucionarlo deberiamos probar otros tipos de desbordamiento</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">48px</span>;
    <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/*Se recorta el contenido (como una mascara)*/</span>
    <span class="hljs-comment">/*overflow: scroll; Genera unas barras de desplazamiento para poder observar todo el contenido dentro de la caja*/</span>
    <span class="hljs-comment">/*overflow: auto; depende del navegador pone un desplazamiento con barras u otro tipo (RECOMENDADO)*/</span>
}
</div></code></pre>
<blockquote>
<p>[!TIP]
Tambien existen propiedades sobre el texto, si tenemos <code>hidden</code> y ponemos <code>text-overflow:ellipsis</code>, hace que la parte que no alcance a salir en la caja le ponga <code>...</code> al final, <strong>recortando lo que no alcanzo a salir</strong>. <code>text-overflow:clip</code> es otro, pero este <strong>recorta exacto con la caja</strong>.</p>
</blockquote>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<hr>
<blockquote>
<p>[!TIP]
La barra del navegador tambien se puede estilar <a href="https://lyqht.github.io/scrollbar-playground/">Scrollbar Playground</a>, se recomienda solo en cajas internas</p>
</blockquote>
<hr>
<h2 id="position">Position</h2>
<p><strong>¿Cómo funcionan las posiciones en CSS?</strong></p>
<p>Funcionan de manera estática, y se van apilando uno al lado o debajo del otro, la cual por defecto es <code>position:static</code>.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        container
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#ccc</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">box-sizing</span>: border-box;
}

<span class="hljs-selector-class">.container</span> {
    background #09f;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-comment">/*position: static;*/</span>
}

<span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">188</span>, <span class="hljs-number">228</span>, <span class="hljs-number">255</span>);
}
</div></code></pre>
<h3 id="absolute">Absolute</h3>
<blockquote>
<p>Relativa al documento</p>
</blockquote>
<p>sin embargo tenemos mas opciones como <code>absolute</code>, podemos determinar sus coordenadas dentro del documento</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#ccc</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">box-sizing</span>: border-box;
}

<span class="hljs-selector-class">.container</span> {
    background #09f;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">position</span>: absolute; <span class="hljs-comment">/*Posicion respecto al doc*/</span>
    <span class="hljs-comment">/*
    lo movemos a la esquina superior derecha de la pantalla
    top:0;
    right:0 Tambien se puede %
    al final se sale de la caja :(
    */</span>
}

<span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">188</span>, <span class="hljs-number">228</span>, <span class="hljs-number">255</span>);
}
</div></code></pre>
<blockquote>
<p>[!TIP]
Centrar un <code>div</code> con <code>absolute</code> es posible <code>top:0;left:0;bottom:0;right:0;margin:auto;</code> haciendo que tenga la misma medida hacia todos los lados y centrandose en el centro. <strong>(Útiles para modales o dialogos)</strong>. la siguiente configuración  <code>inset:0; margin:auto;</code> resume todo lo anterior.</p>
</blockquote>
<h3 id="relative">Relative</h3>
<blockquote>
<p>Relativa al padre</p>
</blockquote>
<p>Pero en ciertos casos queremos ubicarnos respecto a otro elemento, en este contexto tenemos <code>relative</code>, permitienonos movernos sobre un elemento y sin salirnos de él como el <code>absolute</code>.</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#ccc</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">box-sizing</span>: border-box;
}

<span class="hljs-selector-class">.container</span> {
    background #09f;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-comment">/*Ubicado en la esquina inferior izquierda de la caja*/</span>
    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>; 
}

<span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">188</span>, <span class="hljs-number">228</span>, <span class="hljs-number">255</span>);
}
</div></code></pre>
<h3 id="fixed">Fixed</h3>
<blockquote>
<p>Relativa a la pantalla</p>
</blockquote>
<p>Similar al absolute, pero lo que hace es que siempre este en esa posición de la pantalla, es decir, si hacemos <em>scroll</em> serguiá en el mismo sitio, por lo que son relativas a la pantalla</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#ccc</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">box-sizing</span>: border-box;
}

<span class="hljs-selector-class">.container</span> {
    background #09f;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">position</span>: fixed;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>; 
}

<span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">188</span>, <span class="hljs-number">228</span>, <span class="hljs-number">255</span>);
}
</div></code></pre>
<blockquote>
<p>[!TIP]
Útil para ventanas flotantes de ayuda o soporte, barras de navegación o menús</p>
</blockquote>
<h3 id="sticky">Sticky</h3>
<blockquote>
<p>Relativo al contenedor y pantalla</p>
</blockquote>
<p>Se va mantener en su posición del contenedor, sin embargo, si me desplazo hacia un lugar donde no se vea, el elemento se movera con por el contenedor para seguir previsualizandose, hasta que ya llegue al otro extremo del contenedor. <em>&quot;Se mantiene pegado por la pantalla dentro del contenedor&quot;</em>.</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#ccc</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">box-sizing</span>: border-box;
}

<span class="hljs-selector-class">.container</span> {
    background #09f;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">position</span>: sticky;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>; 
}

<span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">188</span>, <span class="hljs-number">228</span>, <span class="hljs-number">255</span>);
}
</div></code></pre>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<h2 id="z-index">z-index</h2>
<p>Se refiere a las posiciones de los elementos uno sobre el otro, <strong>similar al photoshop con las capas</strong>, se le conoce como <code>Contexto de apilamiento</code>.</p>
<p>Para poder modificar cual capa esta en determinada posición podemos usar <code>z-index</code>.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        container
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        container
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-tag">section</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#ccc</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
    <span class="hljs-attribute">box-sizing</span>: border-box;
    <span class="hljs-attribute">position</span>: relative
}

<span class="hljs-selector-class">.container</span> {
    background #09f;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">position</span>: fixed;
    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>; 
    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">10</span>; <span class="hljs-comment">/*posición del eje z/profundidad*/</span>
}

<span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">188</span>, <span class="hljs-number">228</span>, <span class="hljs-number">255</span>);
}
</div></code></pre>
<p>Se recomienda usar los números deforma controlada y necesario, es decir, no usar el <code>z-index:99999;</code>. Se puede realizar con variables.</p>
<blockquote>
<p>[!IMPORTANT]
Para usar los <code>z-index</code>, es necesario crear los <a href="https://developer-mozilla-org.translate.goog/en-US/docs/Web/CSS/CSS_positioned_layout/Stacking_context?_x_tr_sl=en&amp;_x_tr_tl=es&amp;_x_tr_hl=es&amp;_x_tr_pto=tc">conceptos de apilamiento</a></p>
</blockquote>
<blockquote>
<p>Entre mas grande el valor del <code>z-index</code> mas arriba en las capas.</p>
</blockquote>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<hr>
<h2 id="flexbox">Flexbox</h2>
<p>Con <code>display:block;</code> que por defecto lo trae el elemento <code>div</code> se realizan saltos de linea por elemento ocupando todo el espacio horizontalmente. Si tenemos <code>display:inline</code> serán como textos, uno al lado del otro <em>(no hay salto de linea, no hay ancho ni alto-solo texto)</em>.</p>
<p><strong>¿Qué es Flexbox?</strong></p>
<p>Entonces nace un tipo de <code>display</code> que establece como tiene que funcionar el contenedor respecto a sus hijos, es decir, que va a ser variable dependiendo de los hijos mediante el valor <code>flex</code>.</p>
<p>Entonces en el siguiente ejemplo al usar <code>flex</code> se ubicarán todas las cajas en la primera fila, <strong>variando su tamaño dependiendo del contenedor</strong>, es decir, si el contenedor es angosto, todas las cajas reduciran su ancho para caber equitativamente en su contenedor</p>
<p><strong>¿Por qué en una fila?</strong></p>
<p>Esto debido a que por defecto esta configurado como filas, esto se puede modificar a <strong>columnas</strong> tambien.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-selector-class">.parent</span> {
    <span class="hljs-attribute">display</span>: flex;
}

<span class="hljs-selector-class">.item</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;
    <span class="hljs-attribute">opacity</span>: .<span class="hljs-number">9</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#09f</span>;
    <span class="hljs-comment">/*display: inline; lo vuelve como un texto*/</span>
}

<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:first-child</span> {
    <span class="hljs-attribute">background</span>: yellow;
}

<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:last-child</span> {
    <span class="hljs-attribute">background</span>: red;
}
</div></code></pre>
<h3 id="%C2%BFc%C3%B3mo-le-cambio-de-filas-a-columnas-o-vice-versa">¿Cómo le cambio de filas a columnas o vice-versa?</h3>
<p>Para ello usamos <code>flex-direction: row</code> por filas o <code>flex-direction: column</code> por columnas. Si le aplicamos el valor <code>column</code> ahora veremos una columna con las cajas en el ejemplo anterior.</p>
<blockquote>
<p>[!IMPORTANT]
Flex es <strong>unidireccional</strong>, solo puedo trabajar o filas o columnas, no puedo trabajar ambas en el mismo contenedor.</p>
</blockquote>
<p>Tambien se tienen los siguientes valores:</p>
<ul>
<li>
<p><code>row-reverse</code>: En fila pero pone el contenido al reves, de derecha a izquierda.</p>
</li>
<li>
<p><code>column-reverse</code>: En columna pero pone el contenido de abajo hacia arriba.</p>
</li>
<li>
<p><code>flex</code>: dirección por defecto <em>(filas)</em></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flex direction docs</a></p>
</li>
</ul>
<blockquote>
<p>[!TIP]
Tambien podemos darle la vuelta al contenido de derecha a izquierda usando <code>direction:rtl;</code>, tambien podemos ponerlo vertical <em>(columnas)</em> de izquierda a derecha con <code>writing-mode: vertical-lr</code>. <strong>útil para ciertos idiomas</strong></p>
</blockquote>
<h3 id="flex-wrap">Flex-wrap</h3>
<p>Si no existe suficiente espacio en el contenedor lo ajusta para que quepa, esto por defecto usa <code>flex-wrap: nowrap</code>. <strong>Que forzadamente lo hace caber</strong>.</p>
<p><strong>¿Pero si no quiero modificar el elemento?</strong></p>
<p>Para ello usamos <code>wrap</code>, este si el contenido se llega a <strong>desbordar</strong>, produce el salto de linea para no modificar los elementos</p>
<blockquote>
<p>[!NOTE]
Se puede resumir con propiedad y valor en uno solo mediante <code>flex-flow: row wrap;</code></p>
</blockquote>
<h3 id="%C2%BFc%C3%B3mo-controlo-el-espacio-de-los-elementos-flexibles">¿Cómo controlo el espacio de los elementos flexibles?</h3>
<p>En ciertos casos queremos hacer que los elementos a parte de que se apilen de determinada forma, <strong>traten de ocupar todo el espacio que se tiene</strong>. Esto por defecto lo mantiene al comienzo porque tenemos las siguientes propiedades:</p>
<ul>
<li><code>flex-grow: 0</code>: los elementos NO crecen</li>
<li><code>flex-shrink: 1</code>: los elementos pueden reducir su tamaño a un tamaño más pequeño que su flex-basis</li>
<li><code>flex-basis: auto</code>: los elementos tienen un tamaño base en automático</li>
</ul>
<blockquote>
<p>Todo lo anterior se resume con <code>flex: initial</code></p>
</blockquote>
<p>Entonces si lo ajustamos con en los hijos:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.item</span> {
    <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;
    <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;
    <span class="hljs-attribute">flex-basis</span>: auto;  
}
</div></code></pre>
<blockquote>
<p>Hará que el primero ocupe su tamaño y reduzcan los otros.</p>
</blockquote>
<p>Y si le ponemos 0 a la base:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.item</span> {
    <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;
    <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;
    <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">0</span>;  
}
</div></code></pre>
<blockquote>
<p>Hará que todos los elementos tengan el mismo ancho</p>
</blockquote>
<p><strong>¿Se puede resumir todo eso?</strong></p>
<p>Si, con <code>flex: 1;</code> tendríamos que los <em>elementos pueden crecer, pueden reducir su tamaño mas pequeño que el basis y con basis 0 el mismo espacio para todos</em>.</p>
<p>Ademas el <code>1</code>, índica una medida relativa de cuanto espacio ocupan los elementos. Es decir, si usamos en uno de los elementos <code>flex: 2</code>, el elemento ocupara el <strong>doble de espacio</strong>, y asi sucesivamente con los valores, 4 sería el cuadruple, 3 el triple, etc.</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.parent</span> {
    <span class="hljs-attribute">display</span>: flex;
}

<span class="hljs-selector-class">.item</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;
    <span class="hljs-attribute">opacity</span>: .<span class="hljs-number">9</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;
}

<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:first-child</span> {
    <span class="hljs-attribute">background</span>: yellow;
    <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span>; <span class="hljs-comment">/*El doble*/</span>
}

<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child(2)</span> {
    <span class="hljs-attribute">background</span>: blue;
}

<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:last-child</span> {
    <span class="hljs-attribute">background</span>: red;
}
</div></code></pre>
<h3 id="%C2%BFle-puedo-cambiar-el-orden-a-los-elementos">¿Le puedo cambiar el orden a los elementos?</h3>
<p>Si, con <code>order</code> podemos indicarle que valor ocupe.</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:first-child</span> {
    <span class="hljs-attribute">background</span>: yellow;
    <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span>; <span class="hljs-comment">/*El doble*/</span>
    <span class="hljs-attribute">order</span>: <span class="hljs-number">3</span>; <span class="hljs-comment">/*ahora aparecerá de terceras*/</span>
}

<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:nth-child(2)</span> {
    <span class="hljs-attribute">background</span>: blue;
    <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/*Ahora eres el primero*/</span>
}

<span class="hljs-selector-class">.item</span><span class="hljs-selector-pseudo">:last-child</span> {
    <span class="hljs-attribute">background</span>: red;
    <span class="hljs-attribute">order</span>: <span class="hljs-number">2</span>; <span class="hljs-comment">/*Ahora eres el segundo*/</span>
}
</div></code></pre>
<blockquote>
<p>[!NOTE]
Útil para evitar el uso de <code>javascript</code>, e.j. <code>drag &amp; drop</code>, <strong>sin embargo,</strong> se recomienda que sea mas interactivo, ya que el orden inicial si debe venir bien establecido en el <code>HTML</code>, para que <strong>semánticamente tenga sentido</strong>.</p>
</blockquote>
<h3 id="justify-content">Justify-content</h3>
<blockquote>
<p>Para practicar <a href="https://flexboxfroggy.com/">Flexbox Froggy</a></p>
</blockquote>
<p><strong>¿Cómo podría ajustar las cajas sin cambiarles su tamaño dentro de su espacio?</strong></p>
<p>Para poder posicionar tus cajas dentro del padre, es decir, estas cajas tambien tienen sus posiciones dentro del padre <em>(eje x,y)</em>, lo <strong>mas importante</strong> para hacer con flex es distribuir el espacio en el eje principal, es decir, <strong>el eje definido en el flex sería el principal</strong>.</p>
<p>Para poder distribuir las cajas podremos usar <code>justify-content</code> que con los valores:</p>
<ul>
<li><code>center</code>: ubica las cajas al centro</li>
<li><code>space-around</code>: deje espacio equitativamente entre las cajas y deja espacio equitativo entre las cajas y los limites con el padre</li>
<li><code>space-between</code>: deje espacio equitativamente dentro de los elementos <strong>(no hacia afuera de las cajas mas extremas)</strong></li>
<li><code>space-evenly</code>: similar al <code>space-around</code>, pero esté espacio es equitativo entre los elementos y los elementos con los límites con el padre</li>
<li><code>flex-start</code>: por defecto, al inicio todos apilados uno al lado del otro</li>
<li><code>flex-end</code>: al final, apilados uno al lado del otro</li>
</ul>
<h3 id="gap">Gap</h3>
<p>A veces queremos tener control preciso de <strong>separación entre los elementos</strong>, para ello usamos <code>gap</code> y usamos como valor las diferentes unidades que se tienen.</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.parent</span> {
    <span class="hljs-attribute">gap</span>: <span class="hljs-number">16px</span>;
}
</div></code></pre>
<blockquote>
<p>Se posiciona a nivel del eje principal</p>
</blockquote>
<h3 id="align-items">Align-items</h3>
<p><strong>¿Cómo puedo centrarlo verticalmente?</strong></p>
<p>Para ello tenemos <code>align-items</code> que con su valor <code>center</code> podremos centrarlo dentro de su padre perpendicularmente, es decir, si esta <code>flex: row</code> entonces con <code>align-items: center</code> lo centraremos a su eje perpendicular, <strong>las columnas</strong> y vice-versa. En este caso tenemos los siguientes valores:</p>
<ul>
<li><code>flex-start</code>: Los ítems se alinean al <strong>inicio del eje cruzado</strong> (por ejemplo, arriba).</li>
<li><code>flex-end</code>: Se alinean al <strong>final del eje cruzado</strong> (por ejemplo, abajo).</li>
<li><code>center</code>: Los ítems se alinean al <strong>centro del eje cruzado</strong>.</li>
<li><code>baseline</code>: Los ítems se alinean según su <strong>línea base de texto</strong>.</li>
<li><code>stretch</code> (default): Los ítems se <strong>estiran para llenar</strong> el contenedor (si no tienen altura fija).</li>
</ul>
<blockquote>
<p>Se posiciona a nivel del eje perpendicular</p>
</blockquote>
<h3 id="align-content">Align-content</h3>
<p>Con <code>align-content</code> podemos distribuir el <strong>espacio entre las filas</strong> y tenemos los siguientes valores:</p>
<ul>
<li><code>flex-start</code>:Las filas se agrupan al <strong>inicio del contenedor</strong>.</li>
<li><code>flex-end</code>: Las filas se agrupan al <strong>final del contenedor</strong>.</li>
<li><code>center</code>: Las filas se agrupan en el <strong>centro del contenedor</strong>.</li>
<li><code>space-between</code>: Las filas se distribuyen con <strong>espacios iguales entre ellas</strong>.</li>
<li><code>space-around</code>: Igual espacio arriba y abajo de cada fila.</li>
<li><code>space-evenly</code>: <strong>Espacio igualado</strong> entre filas y en los extremos (arriba/abajo).</li>
<li><code>stretch</code> (default): Las filas se <strong>estiran</strong> para llenar el contenedor.</li>
</ul>
<blockquote>
<p>Se posiciona a nivel del contenedor</p>
</blockquote>
<h3 id="align-self">Align-self</h3>
<p>Similar al <code>align-items</code>, pero a nivel individual, un solo elemento. <strong>Para una excepción</strong>.</p>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>
<hr>
<h2 id="grid">Grid</h2>
<blockquote>
<p>Filas y columnas, maquetar la web</p>
</blockquote>
<ul>
<li><a href="https://cssgridgarden.com/">Practicar Grid</a></li>
</ul>
<p>Puedes crear cuadriculas, alterar su orden y superponer elementos <em>(sin usar <code>position:absolute</code>)</em>. Nos permite trabajar con los <strong>dos ejes</strong> a diferencia de <a href="#flexbox">Flexbox</a>.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
</div></code></pre>
<p>Para agregarlo usamos <code>display:grid</code> sobre el contenedor, de tal manera que todo su contenido usará grid. Y mediante:</p>
<ul>
<li><code>grid-template-columns</code>: podemos indicarle la cantidad de columnas y sus medidas</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">background</span>: lightsalmon;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid black;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">display</span>: grid;
    <span class="hljs-attribute">grid-template-columns</span>: auto <span class="hljs-number">20px</span> <span class="hljs-number">100px</span>; <span class="hljs-comment">/*1era auto, 2da 20px y 3era 100px, auto es que lo define el navegador dependiendo del contenido*/</span>
}
<span class="hljs-selector-class">.container</span> <span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">background</span>: lightblue;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#09f</span>;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">6px</span>;
}
<span class="hljs-selector-tag">body</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-number">#ddd</span>;
}
</div></code></pre>
<h3 id="unidad-especial">Unidad especial</h3>
<p>Las fracciones, nos permite <strong>indicar el tamaño de las columnas de forma proporcional</strong>, para ello usamos <code>fr</code></p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr; <span class="hljs-comment">/*Cada una 50%*/</span>
}
<span class="hljs-selector-class">.container2</span> {
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr; <span class="hljs-comment">/*1era es el doble de la 2da*/</span>
}
</div></code></pre>
<blockquote>
<p>[!NOTE]
Tambien se pueden mezclar <code>1fr 100px</code>, en este caso el ancho de la primera sería <code>1fr = ancho del contenedor - 100px</code>.</p>
</blockquote>
<blockquote>
<p>[!WARNING]
Tambien existe el <strong>desborde</strong> con grid, es decir, se pueden salir del contenedor si no esta bien configurado</p>
</blockquote>
<p><strong>¿Puedo tambien configurar las filas?</strong></p>
<p>Si, para ello usamos <code>grid-template-rows</code> y funcionaría de manera similar.</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: grid;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;
    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">50px</span> <span class="hljs-number">30px</span> <span class="hljs-number">100px</span>; <span class="hljs-comment">/*4 filas con diferente altura*/</span>
}
</div></code></pre>
<blockquote>
<p>[!IMPORTANT]
La cuadricula <strong>NO DEPENDE</strong> de los elementos, es decir, puedes crear cuadriculas vacías</p>
</blockquote>
<h3 id="filas-autom%C3%A1ticas">Filas automáticas</h3>
<p>Tambien tenemos <code>grid-auto-rows: 25px</code>, es decir, cuando la grid me cree filas quiero que automaticamente cada una me ocupe <code>25px</code> de alto.</p>
<p>Pero si hago algo asi:</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.container</span> {
    <span class="hljs-attribute">display</span>: grid;
    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;
    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span>;
    <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>;
}
</div></code></pre>
<p>Me crea una fila que ocupe <code>100px</code> y en el espacio siguiente me crea las filas que quepan con <code>50px</code>;</p>
<h3 id="grid-auto-flow">Grid-auto-flow</h3>
<p>Cuando algo no cabe lo genera en filas por defecto <code>grid-auto-flow: row</code>, pero lo podemos cambiar a <code>column</code>, otro sería <code>dense</code> que <strong>rellena los huecos con los que se pueda</strong>.</p>
<h3 id="propiedad-repeat">Propiedad repeat</h3>
<ul>
<li><a href="#contenido">Regresar</a></li>
</ul>

</body>
</html>
